"""
@file upp.py
@brief Universal Path Planner (UPP) for N-dimensional occupancy grids.

@details
Implements a heuristic-guided grid planner that blends two distance measures
and a precomputed safety potential. The environment is an N-D NumPy occupancy
grid where value 0 denotes free space and value 1 denotes an obstacle.

Key ideas:
- Combined distance heuristic: mix of Manhattan and Chebyshev distances.
- Safety potential: fast convolution-based map that increases cost near obstacles.
- Standard open-set search using a priority queue with cumulative path cost.

@par Constructor Arguments
- @p alpha   : float — blend coefficient between Manhattan and Chebyshev distances
- @p beta    : float — weight on the safety potential
- @p radius  : int   — Chebyshev radius for safety kernel support
- @p epsilon : float — small constant to avoid division by zero in the kernel

@par Inputs (to @ref plan())
- @p start : tuple[int, ...] — start grid cell (for example, (row, col))
- @p goal  : tuple[int, ...] — goal grid cell
- @p grid  : numpy.ndarray (N-D), values {0=free, 1=obstacle}

@par Outputs
- @p success : int — 1 if a path is found, else 0
- @p path    : list[tuple[int, ...]] — sequence of cells from start to goal (inclusive)
- @p info    : list[str] — diagnostics (for example, "Invalid goal")

@see BasePlanner
"""
from .baseplanner import BasePlanner
import heapq
import itertools
import numpy as np
from scipy.signal import fftconvolve
from scipy.ndimage import distance_transform_edt


class UPP2(BasePlanner):
    """
    Universal Path Planner blending distance and safety costs.
    """

    def __init__(self, alpha, beta, radius, epsilon):
        self.alpha = alpha
        self.beta = beta
        self.R = radius
        self.epsilon = epsilon

        self.success = 0
        self.info = []
        self.path = []

    # ---------- Utility Functions ----------
    def isValid(self, grid_cell):
        for i in range(self.dimension):
            if not (0 <= grid_cell[i] < self.grid.shape[i]):
                return False
        return True

    def manhattanHeuristics(self, node1, node2):
        return sum(abs(node1[i] - node2[i]) for i in range(self.dimension))

    def chebyshevHeuristics(self, node1, node2):
        return max(abs(a - b) for a, b in zip(node1, node2))

    def adjacentCoordinates(self, node, offsets=[-1, 0, 1]):
        for c in itertools.product(offsets, repeat=self.dimension):
            if all(o == 0 for o in c):
                continue
            yield tuple(node[i] + c[i] for i in range(self.dimension))

    # ---------- Safety Precomputation ----------
    def precomputeSafety(self):
        obs = (self.grid == 1).astype(np.float32)
        R = int(self.R)
        if R <= 0 or not np.any(obs):
            self.preSafety = np.zeros_like(obs, dtype=np.float32)
            return

        nd = obs.ndim
        grids = np.ogrid[tuple(slice(-R, R + 1) for _ in range(nd))]

        from functools import reduce
        d_inf = reduce(np.maximum, (np.abs(g) for g in grids))

        K = np.zeros_like(d_inf, dtype=np.float32)
        mask = (d_inf > 0) & (d_inf <= R)
        K[mask] = 1.0 / (d_inf[mask] + float(self.epsilon))

        S = fftconvolve(obs, K, mode="same")
        self.preSafety = np.maximum(S, 0).astype(np.float32)

    def combinedHeuristics(self, node1, node2):
        optimalCost = (
            self.alpha * self.manhattanHeuristics(node1, node2)
            + (1 - self.alpha) * self.chebyshevHeuristics(node1, node2)
        )
        return optimalCost + self.beta * self.preSafety[node1]

    # ---------- Main A* Planner ----------
    def plan(self, start, goal, grid):
        self.start = tuple(start)
        self.goal = tuple(goal)
        self.grid = grid
        self.path = []
        self.info = []
        self.success = 0
        self.dimension = len(start)

        # validity checks
        if not self.isValid(self.start):
            self.info.append("Invalid start")
            return 0, [], self.info
        if not self.isValid(self.goal):
            self.info.append("Invalid goal")
            return 0, [], self.info
        if self.grid[self.goal] == 1:
            self.info.append("Goal has obstacle")
            return 0, [], self.info
        if self.grid[self.start] == 1:
            self.info.append("Start has obstacle")
            return 0, [], self.info
        if self.start == self.goal:
            self.success = 1
            self.path = [self.start]
            self.info.append("Start and goal are same")
            return 1, self.path, self.info

        # ---------- ✅ NEW: Geometry-aware β update ----------
        D = distance_transform_edt(self.grid == 0).astype(np.float32)
        free = (self.grid == 0)
        rho = float(np.count_nonzero(self.grid == 1)) / float(self.grid.size)
        if np.any(free):
            mu = float(np.mean(D[free]))
            sigma = float(np.std(D[free]))
            beta_raw = self.beta * rho * (sigma / (mu + self.epsilon))
            self.beta = float(np.clip(beta_raw, 0.0, 2.0))
            self.info.append(f"Auto β: {self.beta:.3f}, μ={mu:.2f}, σ={sigma:.2f}, ρ={rho:.3f}")

        # precompute safety potential
        self.precomputeSafety()

        open_set = []
        visited = np.zeros(self.grid.shape, bool)
        parents = {}
        g_score = np.full(self.grid.shape, np.inf, np.float32)
        g_score[self.start] = 0.0

        f0 = self.combinedHeuristics(self.start, self.goal)
        heapq.heappush(open_set, (f0, 0.0, self.start))

        # A* loop
        while open_set:
            _, g, current = heapq.heappop(open_set)

            if current == self.goal:
                self.success = 1
                break

            if visited[current]:
                continue
            visited[current] = True

            for nb in self.adjacentCoordinates(current):
                if not self.isValid(nb) or self.grid[nb] == 1 or visited[nb]:
                    continue

                delta = tuple(nb[i] - current[i] for i in range(self.dimension))
                is_axis_step = sum(abs(d) for d in delta) == 1
                step_cost = 1.0 if is_axis_step else float(np.linalg.norm(delta, ord=2))
                g_new = g + step_cost

                if g_new < g_score[nb]:
                    g_score[nb] = g_new
                    parents[nb] = current
                    f_nb = g_new + self.combinedHeuristics(nb, self.goal)
                    heapq.heappush(open_set, (f_nb, g_new, nb))

        # reconstruct path
        if self.success == 1:
            node = self.goal
            while node != self.start:
                self.path.append(node)
                node = parents.get(node)
                if node is None:
                    self.info.append("Failed to reconstruct path")
                    return 0, [], self.info
            self.path.append(self.start)
            self.path.reverse()

        return self.success, self.path, self.info
